{
 (* File MicroC/CLex.lex
    Lexer specification for micro-C, a small imperative language
  *)

module CLex
  
open Microsoft.FSharp.Text.Lexing
open Microsoft.FSharp.Collections
open CPar;

let lexemeAsString lexbuf = 
    LexBuffer<char>.LexemeString lexbuf

(* Scan keywords as identifiers and use this function to distinguish them. *)
(* If the set of keywords is large, use a hashtable instead.               *)

let keyword s =
    match s with
    | "PI"      -> PI
    | "ItoF"    -> ITOF
    | "itof"    -> ITOF
    | "Float"   -> ITOF
    | "FtoI"    -> FTOI
    | "ftoi"    -> FTOI
    | "Int"     -> FTOI
    | "Sqrt"    -> SQRT
    | "Pow"     -> POW
    | "Log"     -> LOG
    | "Fabs"    -> FABS
    | "Sin"     -> SIN
    | "Cos"     -> COS
    | "Tan"     -> TAN
    | "Asin"    -> ASIN
    | "Acos"    -> ACOS
    | "Atan"    -> ATAN
    | "Round"   -> ROUND
    | "Floor"   -> FLOOR
    | "Ceil"    -> CEIL
    | "Gcd"     -> GCD
    | "Mcm"     -> MCM
    | "Abs"     -> ABS
    | "char"    -> CHAR 
    | "default" -> DEFAULT
    | "do"      -> DO
    | "else"    -> ELSE
    | "false"   -> CSTBOOL 0
    | "for"     -> FOR
    | "if"      -> IF
    | "int"     -> INT
    | "float"   -> FLOAT
    | "String"  -> STRING
    | "string"  -> STRING
    | "null"    -> NULL
    | "print"   -> PRINT
    | "printi"  -> PRINTI
    | "printc"  -> PRINTC
    | "printf"  -> PRINTF
    | "println" -> PRINTLN
    | "return"  -> RETURN
    | "true"    -> CSTBOOL 1
    | "void"    -> VOID 
    | "while"   -> WHILE     
    | "Sort"    -> SORT
    | "Max"     -> MAX
    | "Min"     -> MIN
    | "Swap"    -> SWAP
    | "switch"  -> SWITCH    
    | "case"    -> CASE
    | "default" -> DEFAULT
    | _         -> NAME s
 
let cEscape s = 
    match s with 
    | "\\\\" -> '\\'
    | "\\\"" -> '\"'
    | "\\a"  -> '\007'
    | "\\b"  -> '\008'
    | "\\t"  -> '\t'
    | "\\n"  -> '\n'
    | "\\v"  -> '\011'
    | "\\f"  -> '\012'
    | "\\r"  -> '\r'
    | _      -> failwith "Lexer error: impossible C escape"
}

rule Token = parse
  | ['0']['b']['0'-'9']+  {CSTBIN(System.Int32.Parse ((lexemeAsString lexbuf).[2..]))  } 
  | ['0']['o']['0'-'9']+  {CSTOCT(System.Int32.Parse ((lexemeAsString lexbuf).[2..]))  } 
  | ['0']['x']['0'-'9']+  {CSTHEX(System.Int32.Parse ((lexemeAsString lexbuf).[2..]))  } 
  | [' ' '\t' '\r'] { Token lexbuf }
  | '\n'            { lexbuf.EndPos <- lexbuf.EndPos.NextLine; Token lexbuf }
  | ['0'-'9']+      { CSTINT (System.Int32.Parse (lexemeAsString lexbuf)) }  
  | ['''] [' '-'ÿ']* [''']  { CSTCHAR ((lexemeAsString lexbuf).[1]) } 
  | ['0'-'9']+'.'['0'-'9']+ { CSTFLOAT (System.Double.Parse (lexemeAsString lexbuf)) }  
  | ['a'-'z''A'-'Z']['a'-'z''A'-'Z''0'-'9']*
                    { keyword (lexemeAsString lexbuf) }
  | "**"            { INVO }
  | ['"'] [' '-'ÿ']* ['"']      { CSTSTRING (lexemeAsString lexbuf) }
  | '+'             { PLUS } 
  | "++"            { PLUSONE }
  | "--"            { MINUSONE }
  | '-'             { MINUS } 
  | '*'             { TIMES } 
  | '/'             { DIV } 
  | '%'             { MOD }                     
  | '='             { ASSIGN }
  | "+="            { PLUSASSIGN }
  | "-="            { MINUSASSIGN } 
  | "*="            { TIMESASSIGN } 
  | "/="            { DIVASSIGN } 
  | "%="            { MODASSIGN } 
  | "&="            { BITANDASSIGN }
  | "|="            { BITORASSIGN } 
  | "^="            { BITXORASSIGN } 
  | "<<="           { BITLEFTASSIGN } 
  | ">>="           { BITRIGHTASSIGN } 
  | "=="            { EQ } 
  | "!="            { NE }
  | '>'             { GT }
  | '<'             { LT }
  | ">="            { GE }
  | "<="            { LE }
  | "||"            { SEQOR }                     
  | "&&"            { SEQAND }                     
  | "&"             { AMP }
  | "~"             {BITNOT}
  | "<<"            {BITLEFT}
  | ">>"            {BITRIGHT}
  | "^"             {BITXOR}       
  | "|"             {BITOR}
  | "!"             { NOT }                     
  | '('             { LPAR }
  | ')'             { RPAR }
  | '{'             { LBRACE }
  | '}'             { RBRACE }
  | '['             { LBRACK }
  | ']'             { RBRACK }
  | ';'             { SEMI }
  | ','             { COMMA }
  | ':'             { COLON }
  | '?'             { QUESTION }
  | "//"            { EndLineComment lexbuf; Token lexbuf }
  | "/ /"            { EndLineComment lexbuf; Token lexbuf }
  | "/*"            { Comment lexbuf; Token lexbuf }
  | "(*"            { Comment lexbuf; Token lexbuf }
  | eof             { EOF }
  | _               { failwith "Lexer error: illegal symbol" }

and Comment = parse
   | "/*"           { Comment lexbuf; Comment lexbuf }  
   | "*/"           { () }
   | "(*"           { Comment lexbuf; Comment lexbuf }  
   | "*)"           { () }
   | '\n'           { lexbuf.EndPos <- lexbuf.EndPos.NextLine; Comment lexbuf }
   | (eof | '\026') { failwith "Lexer error: unterminated comment" }
   | _              { Comment lexbuf }

and EndLineComment = parse
   | '\n'           { lexbuf.EndPos <- lexbuf.EndPos.NextLine }
   | (eof | '\026') { () }
   | _              { EndLineComment lexbuf }

and String chars = parse 
  | '"'
      { Microsoft.FSharp.Core.String.concat "" (List.map string (List.rev chars)) }
  | '\\' ['\\' '"' 'a' 'b' 't' 'n' 'v' 'f' 'r']
      { String (cEscape (lexemeAsString lexbuf) :: chars) lexbuf }
  | "''" 
      { String ('\'' :: chars) lexbuf }
  | '\\'
      { failwith "Lexer error: illegal escape sequence" }
  | (eof | '\026')
      { failwith "Lexer error: unterminated string" }
  | ['\n' '\r']
      { failwith "Lexer error: newline in string" }
  | ['\000'-'\031' '\127' '\255']
      { failwith "Lexer error: invalid character in string" }
  | _
      { String (char (lexbuf.LexemeChar 0) :: chars) lexbuf }
