%{
(*	File MicroC/CPar.fsy 
	Parser specification for micro-C, a small imperative language
	sestoft@itu.dk * 2009-09-29
	No (real) shift/reduce conflicts thanks to Niels Kokholm.
*)

open Absyn

// Vardesc 返回的是一个 元组 (g,s)
// g是类型构造函数，s是变量名

let compose1 f (g, s) = ((fun x -> g(f(x))), s)
let nl = CstI 10
%}
%token <int> CSTINT CSTBOOL CSTHEX CSTOCT CSTBIN
%token <float> CSTFLOAT
%token <string> CSTSTRING NAME 

%token COS SIN TAN ASIN ACOS ATAN CHAR ELSE IF INT FLOAT NULL PRINT PRINTI PRINTC PRINTF PRINTLN RETURN VOID WHILE DO FOR DEFAULT SORT MAX MIN SWAP ABS SWITCH CASE GCD MCM ROUND FLOOR CEIL FTOI ITOF PI FABS LOG SQRT POW

%token PLUS MINUS TIMES DIV MOD PLUSONE MINUSONE INVO
%token EQ NE GT LT GE LE
%token NOT SEQOR SEQAND
%token LPAR RPAR LBRACE RBRACE LBRACK RBRACK SEMI COMMA ASSIGN AMP 
%token PLUSASSIGN MINUSASSIGN TIMESASSIGN DIVASSIGN MODASSIGN COLON QUESTION BITAND BITOR BITXOR BITLEFT BITRIGHT BITANDASSIGN BITORASSIGN BITXORASSIGN BITLEFTASSIGN BITRIGHTASSIGN BITNOT
%token EOF


%right ASSIGN PLUSASSIGN MINUSASSIGN TIMESASSIGN DIVASSIGN MODASSIGN   BITANDASSIGN BITORASSIGN BITXORASSIGN BITLEFTASSIGN BITRIGHTASSIGN          /* lowest precedence */
%nonassoc PRINT PRINTI PRINTC PRINTF
%right COLON QUESTION
%left SEQOR
%left SEQAND
%left BITXOR BITOR  BITAND
%left EQ NE 
%nonassoc GT LT GE LE
%left BITLEFT BITRIGHT
%left PLUS MINUS
%left TIMES DIV MOD 
%right INVO
%nonassoc BITNOT NOT AMP PLUSONE MINUSONE
%nonassoc LBRACK          /* highest precedence  */

%start Main
%type <Absyn.program> Main 

%%

Main:
    Topdecs EOF                         { Prog $1 }
;

Topdecs:
    /* empty */                         { [] }
  | Topdec Topdecs                      { $1 :: $2 }
;

Topdec: 
    Vardec SEMI                         { Vardec (fst $1, snd $1) }
  | Fundec                              { $1 }
;

Vardec:
    Type Vardesc                        { ((fst $2) $1, snd $2) }
;

//let compose1 f (g, s) = ((fun x -> g(f(x))), s)
Vardesc: 
    NAME                                { ((fun t -> t), $1)                      }
  | TIMES Vardesc                       { compose1 TypP $2                        }
  | LPAR Vardesc RPAR                   { $2                                      } 
  | Vardesc LBRACK RBRACK               { compose1 (fun t -> TypA(t, None)) $1    }
  | Vardesc LBRACK CSTINT RBRACK        { compose1 (fun t -> TypA(t, Some $3)) $1 }
;

Fundec:
    VOID NAME LPAR Paramdecs RPAR Block { Fundec(None,     $2, $4, $6) }
  | Type NAME LPAR Paramdecs RPAR Block { Fundec(Some($1), $2, $4, $6) }
;

Paramdecs:
    /* empty */                         { [] }
  | Paramdecs1                          { $1 }
;

Paramdecs1:
    Vardec                              { [$1]     }
  | Vardec COMMA Paramdecs1             { $1 :: $3 }
;

Block:
    LBRACE StmtOrDecSeq RBRACE          { Block $2 }
;

StmtOrDecSeq:
    /* empty */                         { [] }
  | Stmt StmtOrDecSeq                   { Stmt $1 :: $2 }
  | Vardec SEMI StmtOrDecSeq            { Dec (fst $1, snd $1) :: $3 }
;

Stmt: 
    StmtM                               { $1 }
  | StmtU                               { $1 }
;

StmtM:  /* No unbalanced if-else */
    Expr SEMI                           { Expr($1)             }
  | RETURN SEMI                         { Return None          }
  | RETURN Expr SEMI                    { Return(Some($2))     }
  | Block                               { $1                   }
  | IF LPAR Expr RPAR StmtM ELSE StmtM  { If($3, $5, $7)       }
  | WHILE LPAR Expr RPAR StmtM          { While($3, $5)        }
  | DO StmtM WHILE LPAR Expr RPAR       { Do($2, $5)           }
  | FOR LPAR Expr SEMI Expr SEMI Expr RPAR StmtM  { For($3, $5, $7, $9) } 
  | SWITCH LPAR Expr RPAR LBRACE Caselist RBRACE { Switch($3, $6)   }
;

StmtU:
    IF LPAR Expr RPAR StmtM ELSE StmtU  { If($3, $5, $7)       }
  | IF LPAR Expr RPAR Stmt              { If($3, $5, Block []) }
  | WHILE LPAR Expr RPAR StmtU          { While($3, $5)        }
  | DO StmtU WHILE LPAR Expr RPAR       { Do($2, $5)           }
  | FOR LPAR Expr SEMI Expr SEMI Expr RPAR StmtU  { For($3, $5, $7, $9) } 
  | SWITCH LPAR Expr RPAR LBRACE Caselist RBRACE { Switch($3, $6)   }
;

Caselist:
    Casedec                               { [$1] }
  | Casedec Caselist                      { $1 :: $2 }
;

Casedec:
    CASE CSTINT COLON Block SEMI            { ($2, $4) }
;

Expr: 
    Access                              { Access $1           }
  | ExprNotAccess                       { $1                  }
;

ExprNotAccess:
    AtExprNotAccess                     { $1                  }
  | Access ASSIGN Expr                  { Assign($1, $3)      }
  | NAME LPAR Exprs RPAR                { Call($1, $3)        }  
  | NOT Expr                            { Prim1("!", $2)      }
  | PRINT Expr                          { Prim1("printi", $2) }
  | PRINTI Expr                         { Prim1("printi", $2) }
  | PRINTC Expr                         { Prim1("printc", $2) }
  | PRINTF Expr                         { Prim1("printf", $2) }
  | PRINTLN                             { Prim1("printc", nl) }
  | Expr PLUS  Expr                     { Prim2("+",  $1, $3) }
  | Access PLUSONE                      { P2("+", $1)         }
  | Access MINUSONE                     { P2("-", $1)         }
  | PLUSONE Access                      { P1($2, "+")         }
  | MINUSONE Access                     { P1($2, "-")         }
  | Access PLUSASSIGN Expr              { A("+", $1, $3)      }
  | Access MINUSASSIGN Expr             { A("-", $1, $3)      }
  | Access TIMESASSIGN Expr             { A("*", $1, $3)      }
  | Access DIVASSIGN Expr               { A("/", $1, $3)      }
  | Access MODASSIGN Expr               { A("%", $1, $3)      }
  | Expr MINUS Expr                     { Prim2("-",  $1, $3) }
  | Expr TIMES Expr                     { Prim2("*",  $1, $3) }
  | Expr DIV   Expr                     { Prim2("/",  $1, $3) }
  | Expr MOD   Expr                     { Prim2("%",  $1, $3) }
  | Expr EQ    Expr                     { Prim2("==", $1, $3) }
  | Expr NE    Expr                     { Prim2("!=", $1, $3) }
  | Expr GT    Expr                     { Prim2(">",  $1, $3) }
  | Expr LT    Expr                     { Prim2("<",  $1, $3) }
  | Expr GE    Expr                     { Prim2(">=", $1, $3) }
  | Expr LE    Expr                     { Prim2("<=", $1, $3) }
  | Expr INVO  Expr                     { Prim2("**", $1, $3) }
  | Expr SEQAND Expr                    { Andalso($1, $3)     }
  | Expr SEQOR  Expr                    { Orelse($1, $3)      }
  | Expr AMP Expr                       { Bitand($1, $3)      }
  | Expr BITOR  Expr                    { Bitor($1, $3)       }
  | Expr BITXOR Expr                    { Bitxor($1, $3)      }
  | Expr BITLEFT Expr                   { Bitleft($1, $3)     }
  | Expr BITRIGHT Expr                  { Bitright($1, $3)    }
  | MAX LPAR Expr COMMA Expr RPAR       { Max($3, $5)         }
  | MIN LPAR Expr COMMA Expr RPAR       { Min($3, $5)         }
  | SWAP LPAR Access COMMA Access RPAR  { Swap($3, $5)        }
  | ABS LPAR Expr RPAR                  { Abs($3)             }
  | SQRT LPAR Expr RPAR                 { Sqrt($3)            }
  | FABS LPAR Expr RPAR                 { Fabs($3)            }
  | LOG LPAR Expr RPAR                  { Log($3)             }
  | POW LPAR Expr COMMA Expr RPAR       { Pow($3, $5)         }
  | COS LPAR Expr RPAR                  { Cos($3)             }
  | TAN LPAR Expr RPAR                  { Tan($3)             }
  | ASIN LPAR Expr RPAR                 { Asin($3)            }
  | ACOS LPAR Expr RPAR                 { Acos($3)            }
  | ATAN LPAR Expr RPAR                 { Atan($3)            }
  | SIN LPAR Expr RPAR                  { Sin($3)             }
  | ROUND LPAR Expr RPAR                { Round($3)           }
  | PI                                  { Pi                  }
  | LPAR FTOI RPAR Expr                 { Ftoi($4)            }
  | LPAR ITOF RPAR Expr                 { Itof($4)            }
  | FLOOR LPAR Expr RPAR                { Floor($3)           }
  | CEIL LPAR Expr RPAR                 { Ceil($3)            }
  | GCD LPAR Expr COMMA Expr RPAR       { Gcd($3, $5)         }
  | MCM LPAR Expr COMMA Expr RPAR       { Mcm($3, $5)         }
  | BITNOT Expr                         { Bitnot("~", $2)     }
  | Access BITANDASSIGN Expr            { Bitassign("&",$1, $3)      }
  | Access BITORASSIGN  Expr            { Bitassign("|",$1, $3)      }
  | Access BITXORASSIGN Expr            { Bitassign("^",$1, $3)      }
  | Access BITLEFTASSIGN Expr           { Bitassign("<<",$1, $3)      }
  | Access BITRIGHTASSIGN Expr          { Bitassign(">>",$1, $3)      }
  | Expr QUESTION Expr COLON Expr       { Question($1, $3, $5)}
;

AtExprNotAccess:
    Const                               { CstI $1             }
  | ConstF                              { CstF $1             }
  | ConstHEX                            { CstHEX $1           }
  | ConstOCT                            { CstOCT $1           }
  | ConstBIN                            { CstBIN $1           }
  | LPAR ExprNotAccess RPAR             { $2                  } 
  | AMP Access                          { Addr $2             }
  | CSTSTRING                           { CstS $1             }
;

Access:
    NAME                                { AccVar $1           }
  | LPAR Access RPAR                    { $2                  }  
  | TIMES Access                        { AccDeref (Access $2)}
  | TIMES AtExprNotAccess               { AccDeref $2         }
  | Access LBRACK Expr RBRACK           { AccIndex($1, $3)    }   
;

Exprs:
    /* empty */                         { []       }
  | Exprs1                              { $1       }
;

Exprs1:
    Expr                                { [$1]     }
  | Expr COMMA Exprs1                   { $1 :: $3 }
;

Const:
    CSTINT                              { $1       }
  | CSTBOOL                             { $1       }
  | MINUS CSTINT                        { - $2     }
  | NULL                                { -1       }
;

ConstHEX:
    CSTHEX                              { $1       }
  | MINUS CSTHEX                        { - $2     }
;

ConstOCT:
    CSTOCT                              { $1       }
  | MINUS CSTOCT                        { - $2     }
;

ConstBIN:
    CSTBIN                              { $1       }
  | MINUS CSTBIN                        { - $2     }
;

ConstF:
  | CSTFLOAT                            { $1       }
  | MINUS CSTFLOAT                      { - $2     }
;
Type:
    INT                                 { TypI     }
  | CHAR                                { TypC     }
  | FLOAT                               { TypF     }
;
